all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
S <- estimateR(sample.jelly)
S
x<-c(1,3,7,9,13)
x<-x*14
x<-c(1,3,7,9,13)
w<-x*14
(x+w)/15
x <- c(1, 2, 3, 4, 5)
w <- x * 14
x + w / 15
(x + w) / 15
v <- c(16.4, 16.0, 10.1, 16.8, 20.5, NA, 20.2, 13.1, 24.8, 20.2, 25.0, 20.5, 30.5, 31.4, 27.1)
max(v)
j <- c(rnorm(5, mean = 8, sd = 2))
z <- c(rnorm(5, mean = 25, sd = 10))
k <- cbind (j, z)
k
m <- as.matrix(read.table("data/matrix.txt", sep = "\t", header = FALSE))
n <- t(m)
nrow(n)
ncol(n)
require("vegan")
load(BCI)
BCI
data("BCI")
str(BCI)
require("vegan")
rm(list=ls())
require("vegan")
data("BCI")
head(BCI)
rm(list=ls())
require("vegan")
str(BCI)
data("BCI")
str(BCI)
packageVersion("vegan")
data("BCI")
BCI
library(ade4)
data(doubs)
str(doubs)
require(vegan)
sh GitMkdirQB.sh 2.Worksheets/11.PhyloTraits participant_repos.txt
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
```
Load package for writing figures
```{r}
require("png")
require("vegan")
require("pvclust")
require("gplots")
require("gridGraphics")
require("grid")
require("gplots")
require("gridExtra")
```
Load data (note this is raw growth rates)
```{r}
# Raw growth rate data
gr.data <- read.csv("data/grraw.csv", sep=",", header=TRUE)
str(gr.data)
colnames(gr.data)[1]<-"isolate"
# Data standardizing - log10 tranformation
log.gr <- log10(gr.data[,2:19]+1)
# Data standardizing - divide by sum of species growth
gr.std <- gr.data[,2:19] / (apply(gr.data[,2:19], 1, sum))
# Names
resources <- colnames(gr.data[,2:19])
strains <- gr.data[,1]
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
"#7FFF7F", "yellow", "#FF7F00", "red",
"#7F0000"))
distance <- "euclidean"
# manhattan, correlation, uncentered,
# abscor, euclidean, bray
# Identify agglomerative method
clust <- "average"
# complete = furthest neighbor; compact clusters, sensitive to outliers
# average = UPGMA; considered robust
# ward.D = popular, but makes clusters of equal size and sensitive to outliers
# ward.D2 = dissimilarities are squared before clustering
# mcquitty
# median = downweights outliers
# centroid = fairly robust
# single = nearest neighbor; chaining problem
```
Randomize growth rate data and make heatmap
```{r}
# Randomize growth rate data -- log transformed
log.gr.mat <- as.matrix(log.gr)
colnames(log.gr.mat) <- colnames(gr.data[,2:19])
rownames(log.gr.mat) <- gr.data[,1]
rand <- matrix(sample(log.gr.mat), nrow = nrow(log.gr))
distance <- "euclidean"
# manhattan, correlation, uncentered,
# abscor, euclidean, bray
clust <- "average"
# complete = furthest neighbor; compact clusters, sensitive to outliers
# average = UPGMA; considered robust
# ward.D = popular, but makes clusters of equal size and sensitive to outliers
# ward.D2 = dissimilarities are squared before clustering
# mcquitty
# median = downweights outliers
# centroid = fairly robust
# single = nearest neighbor; chaining problem
log.gr.mat <- as.matrix(log.gr)
colnames(log.gr.mat) <- colnames(gr.data[,2:19])
rownames(log.gr.mat) <- gr.data[,1]
rand <- matrix(sample(log.gr.mat), nrow = nrow(log.gr))
rand.heat <- heatmap.2(as.matrix(rand), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
rand.heat <- heatmap.2(as.matrix(rand), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = jet.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
col.means <-colMeans(log.gr)
# Calculate standard deviation of columns
col.sd <- apply(log.gr, 2, sd)
# Create dataframe with mean column and sd
col.wise <- mapply(rnorm, nrow(log.gr), col.means, col.sd/30)
colnames(col.wise) <- resources
# Make heatmap
col.heat <- heatmap.2(as.matrix(col.wise), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
yellow.red.colors <- colorRampPalette(c("yellow","orange", "red"))
log.gr.mat <- as.matrix(log.gr)
colnames(log.gr.mat) <- colnames(gr.data[,2:19])
rownames(log.gr.mat) <- gr.data[,1]
rand <- matrix(sample(log.gr.mat), nrow = nrow(log.gr))
rand.heat <- heatmap.2(as.matrix(rand), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
rand.heat <- heatmap.2(as.matrix(rand), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
```
Load package for writing figures
```{r}
require("png")
require("vegan")
require("pvclust")
require("gplots")
require("gridGraphics")
require("grid")
require("gplots")
require("gridExtra")
```
Load data (note this is raw growth rates)
```{r}
# Raw growth rate data
gr.data <- read.csv("data/grraw.csv", sep=",", header=TRUE)
str(gr.data)
colnames(gr.data)[1]<-"isolate"
# Data standardizing - log10 tranformation
log.gr <- log10(gr.data[,2:19]+1)
# Data standardizing - divide by sum of species growth
gr.std <- gr.data[,2:19] / (apply(gr.data[,2:19], 1, sum))
# Names
resources <- colnames(gr.data[,2:19])
strains <- gr.data[,1]
```
Customize Color Palette
```{r}
#jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
"#7FFF7F", "yellow", "#FF7F00", "red",
"#7F0000"))
#gray.colors <- gray.colors(25, start = 0.9, end = 0.1, gamma = 1.5, alpha = 1)
yellow.red.colors <- colorRampPalette(c("yellow","orange", "red"))
```
Clustering parameters
```{r}
distance <- "euclidean"
# manhattan, correlation, uncentered,
# abscor, euclidean, bray
# Identify agglomerative method
clust <- "average"
# complete = furthest neighbor; compact clusters, sensitive to outliers
# average = UPGMA; considered robust
# ward.D = popular, but makes clusters of equal size and sensitive to outliers
# ward.D2 = dissimilarities are squared before clustering
# mcquitty
# median = downweights outliers
# centroid = fairly robust
# single = nearest neighbor; chaining problem
```
Randomize growth rate data and make heatmap
```{r}
# Randomize growth rate data -- log transformed
log.gr.mat <- as.matrix(log.gr)
colnames(log.gr.mat) <- colnames(gr.data[,2:19])
rownames(log.gr.mat) <- gr.data[,1]
rand <- matrix(sample(log.gr.mat), nrow = nrow(log.gr))
# # Randomize growth rate data -- non-transformed
# gr.mat <- as.matrix(gr.data[,2:19])
# colnames(gr.mat) <- colnames(gr.data[,2:19])
# rownames(gr.mat) <- gr.data[,1]
# rand <- matrix(sample(gr.mat), nrow = nrow(gr.data))
# Randomize growth rate data -- standardized, non-transformed
# This creates nice visual when randomizing by rows and colums, and also when randomizing by column
# But of course, when radnomizing by row, the standardization has already effectively elminated strain variation
# This results in a random-like matrix.
# gr.mat <- as.matrix(gr.std)
# colnames(gr.mat) <- colnames(gr.data[,2:19])
# rownames(gr.mat) <- gr.data[,1]
# rand <- matrix(sample(gr.mat), nrow = nrow(gr.data))
# Make heatmap
rand.heat <- heatmap.2(as.matrix(rand), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
col.means <-colMeans(log.gr)
# Calculate standard deviation of columns
col.sd <- apply(log.gr, 2, sd)
# Create dataframe with mean column and sd
col.wise <- mapply(rnorm, nrow(log.gr), col.means, col.sd/30)
colnames(col.wise) <- resources
# Make heatmap
col.heat <- heatmap.2(as.matrix(col.wise), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
row.means <-rowMeans(log.gr)
# Calculate standard deviation of rows
row.sd <- apply(log.gr, 1, sd)
# Create dataframe with mean rows and sd
row.wise <- t(mapply(rnorm,ncol(log.gr), row.means, row.sd/30))
colnames(row.wise) <- colnames(log.gr)
row.heat <- heatmap.2(as.matrix(row.wise), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
```
Actual growth rate data as heatmap
```{r}
actual.heat <- heatmap.2(as.matrix(log.gr), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = yellow.red.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources)
plot.new()
heat.list <- list(rand, col.wise, row.wise, log.gr)
# Function for running through list
grab_grob <- function(){
grid.echo()
grid.grab()
}
heat.list <- list(rand, col.wise, row.wise, log.gr)
# Function for running through list
grab_grob <- function(){
grid.echo()
grid.grab()
}
gl <- lapply(1:4, function(i){
heatmap.2(as.matrix(heat.list[[i]]), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = yellow.red.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources, key = FALSE, keysize = 1.0, symkey = FALSE,
scale = "none", cexRow = 0.75, cexCol = 0.75,
lmat = rbind( c(0, 3), c(2,1), c(0,4) ), lhei = c(0.25, 4, 0.25 ),
)
grab_grob()
})
heat.list <- list(rand, col.wise, row.wise, log.gr)
# Function for running through list
grab_grob <- function(){
grid.echo()
grid.grab()
}
gl <- lapply(1:4, function(i){
heatmap.2(as.matrix(heat.list[[i]]), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = yellow.red.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources, key = FALSE, keysize = 1.0, symkey = FALSE,
scale = "none", cexRow = 0.75, cexCol = 0.75,
lmat = rbind( c(0, 3), c(2,1), c(0,4) ), lhei = c(0.25, 4, 0.25 ),
)
grab_grob()
})
png(filename="~/GitHub/PhosTrait/figures/HeatMap.png", width = 2400,
height = 2400, res = 96*2)
grid.newpage()
grid.arrange(grobs = gl, ncol = 2, clip = TRUE)
dev.off()
graphics.off()
rand
heat.list <- list(rand, col.wise, row.wise, log.gr)
# Function for running through list
grab_grob <- function(){
grid.echo()
grid.grab()
}
gl <- lapply(1:4, function(i){
heatmap.2(as.matrix(heat.list[[i]]), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = yellow.red.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources, key = FALSE, keysize = 1.0, symkey = FALSE,
scale = "none", cexRow = 0.75, cexCol = 0.75,
lmat = rbind( c(0, 3), c(2,1), c(0,4) ), lhei = c(0.25, 4, 0.25 ),
)
grab_grob()
})
require("gridGraphics")
install.packages('gridGraphics')
require(gridGraphics')
require('gridGraphics')
heat.list <- list(rand, col.wise, row.wise, log.gr)
# Function for running through list
grab_grob <- function(){
grid.echo()
grid.grab()
}
gl <- lapply(1:4, function(i){
heatmap.2(as.matrix(heat.list[[i]]), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = yellow.red.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources, key = FALSE, keysize = 1.0, symkey = FALSE,
scale = "none", cexRow = 0.75, cexCol = 0.75,
lmat = rbind( c(0, 3), c(2,1), c(0,4) ), lhei = c(0.25, 4, 0.25 ),
)
grab_grob()
})
png(filename="~/GitHub/PhosTrait/figures/HeatMap.png", width = 2400,
height = 2400, res = 96*2)
grid.newpage()
grid.arrange(grobs = gl, ncol = 2, clip = TRUE)
dev.off()
graphics.off()
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
require("png")
require("vegan")
require("phylolm")
require("muscle")
require("seqinr")
require("ape")
gr.data <- read.csv("data/grraw.csv", sep=",", header = TRUE, row.names = 1)
str(gr.data)
# Standadize Growth Rates Across Strains
gr.std <- gr.data / (apply(gr.data, 1, sum))
# Calculate Max Growth Rate
umax <- as.matrix((apply(gr.data, 1, max)))
levins <- function(p_xi = ""){
p = 0
for (i in p_xi){
p = p + i^2
}
nb = 1 / (length(p_xi) * p)
return(nb)
}
# Calculate niche breadth for Each Isolate
nb <- as.matrix(levins(gr.std))
rownames(nb) <- rownames(gr.data)
colnames(nb) <- c("nb")
# Read Alignment File {seqinr}
read.aln <- read.alignment(file = "./data/p.isolates.afa", format = "fasta")
# Convert Alignment File to DNAbin Object {ape}
p.DNAbin <- as.DNAbin(read.aln)
# Identify Base Pair Region of 16S rRNA Gene to Visuzlize
window <- p.DNAbin[, 100:500]
# Command to Visusalize Sequence Alignment {ape}
image.DNAbin(window, cex.lab = 0.50)
ml.bootstrap <- read.tree("./data/RAxML_bestTree.LTDE.ML")
str(ml.bootstrap)
outgroup <- match("Methanosarcina", ml.bootstrap$tip.label)
# Root the Tree {ape}
ml.rooted <- root(ml.bootstrap, outgroup, resolve.root = TRUE)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.rooted, main = "ML", "phylogram",
use.edge.length = FALSE, direction = "right", cex = 0.6,
label.offset = 1)
add.scale.bar(cex = 0.7)
# Keep Rooted but Drop Outgroup Branch
p.tree <- drop.tip(ml.rooted, "Methanosarcina")
require("png")
require("vegan")
require("phylolm")
require("seqinr")
require("ape")
require("phytools")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("muscle", version = "3.8")
# Read Alignment File {seqinr}
read.aln <- read.alignment(file = "./data/p.isolates.afa", format = "fasta")
# Convert Alignment File to DNAbin Object {ape}
p.DNAbin <- as.DNAbin(read.aln)
# Identify Base Pair Region of 16S rRNA Gene to Visuzlize
window <- p.DNAbin[, 100:500]
# Command to Visusalize Sequence Alignment {ape}
image.DNAbin(window, cex.lab = 0.50)
# Load Maximum Likielihood Tree File
ml.bootstrap <- read.tree("./data/RAxML_bestTree.LTDE.ML")
# Identify Outgroup Sequence
outgroup <- match("Methanosarcina", ml.bootstrap$tip.label)
# Root the Tree {ape}
ml.rooted <- root(ml.bootstrap, outgroup, resolve.root = TRUE)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.rooted, main = "ML", "phylogram",
use.edge.length = FALSE, direction = "right", cex = 0.6,
label.offset = 1)
add.scale.bar(cex = 0.7)
# Keep Rooted but Drop Outgroup Branch
p.tree <- drop.tip(ml.rooted, "Methanosarcina")
gr.data <- read.csv("data/grraw.csv", sep=",", header=TRUE) # column = resources
colnames(gr.data)[1]<-"isolate"
norm.g <- function(x) (x-min(x))/(max(x)-min(x))
norm.g.data <- apply(gr.data[,2:19], 1, norm.g)
colnames(norm.g.data)<-gr.data[,1]
LL <- norm.sort[,1:18]
WG <- norm.sort[,19:39]
plot.new()
matplot(ranks,LL, type = "l", lty = 2, lwd = 2, col = "blue", xlab = "Rank phosphorus preference",
ylab = "Scaled growth rate", xlim = c(0,20), ylim = c(0, 1), las = 1)
matlines(ranks,WG, type = "l", lty = 3, lwd = 1.5, col = "red")
ranks <- as.vector(seq(1, dim(norm.sort)[1]))
norm.sort <- apply(norm.g.data, 2, sort, decreasing=T)
ranks <- as.vector(seq(1, dim(norm.sort)[1]))
LL <- norm.sort[,1:18]
WG <- norm.sort[,19:39]
plot.new()
matplot(ranks,LL, type = "l", lty = 2, lwd = 2, col = "blue", xlab = "Rank phosphorus preference",
ylab = "Scaled growth rate", xlim = c(0,20), ylim = c(0, 1), las = 1)
matlines(ranks,WG, type = "l", lty = 3, lwd = 1.5, col = "red")
evar <- function(x){
x <- as.vector(x[x > 0])
1 - (2/pi)*atan(var(log(x)))
}
evar.LL <- apply(LL,2,evar)
evar.WG <- apply(WG,2,evar)
t.test(evar.LL, evar.WG)
wilcox.test(evar.LL,evar.WG)
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
SimpE <- function(x = ""){
S <- S.obs(x)
x = as.data.frame(x)
D <- diversity(x, "inv")
E <- (D)/S
return(E)
}
simpe.LL <- SimpE(LL)
simpe.LL <- simpe.LL[is.finite(simpe.LL)]
simpe.WG <- SimpE(WG)
simpe.WG <- simpe.WG[is.finite(simpe.WG)]
t.test(simpe.LL, simpe.WG)
wilcox.test(simpe.LL,simpe.WG)
evar.data <-c(evar.LL,evar.WG)
evar.lake <-c(rep("LL", 18), rep("WG",21))
evar.data <- as.data.frame(cbind(evar.lake,evar.data))
phylANOVA(p.tree, evar.data$evar.lake, evar.data$evar.data, nsim=1000)
evar.data
evar.lake
evar.data
evar.data
evar.data$evar.lake
evar.data$evar.data
evar.data <-c(evar.LL,evar.WG)
evar.data
evar.lake <-c(rep("LL", 18), rep("WG",21))
evar.lake
as.data.frame(evar.lake)
evar.data <- cbind(evar.lake,evar.data)
evar.data
evar.data <-c(evar.LL,evar.WG)
evar.lake <-as.data.frame(c(rep("LL", 18), rep("WG",21)))
evar.lake
colnames(evarlake) <- "lake"
colnames(evar.lake) <- "lake"
evar.lake
evar.data <- data.frame(evar.lake, evar.data)
evar.data
phylANOVA(p.tree, evar.data$evar.lake, evar.data$evar.data, nsim=1000)
p.tree
dim(evar.lake)
