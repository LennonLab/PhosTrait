<<<<<<< HEAD
# Define Initial Simulation Options
num.steps <- steps
sim.time <- 0 # reset initial time
n.birth <- 0; n.death <- 0; n.decay <- 0;
n.immigration <- 0; n.emigration <- 0; n.zombie <- 0
# Define OTUs and Rel Abundance in Regional Pool
otus <- paste("OTU", sprintf("%05d", seq(1:200)), sep = "")
#G <- rlnorm(n=length(otus), meanlog = 1, sdlog = 0.98)
G <- rls(n = 1:length(otus), N = length(otus), alpha = 5)
G <<- G[rev(order(G))] # / sum(G)
#plot(G)
#plot(log10(G))
# Initialize Local Community and Relic Tables
N <<- table(otus) * 0; n <- 0
R <<- table(otus) * 0; r <- 0
# Initialize Local Community Membership
comm <- sample(otus, size = 100, replace = T, prob = G)
ind <- which(otus %in% comm)
N[ind] <<- N[ind] + table(comm)
# Save Time and Events
ints <- vector(mode = "numeric", length = 0)
event.list <- vector(mode = "character", length = 0)
N_series <- vector(mode = "numeric", length = 0)
R_series <- vector(mode = "numeric", length = 0)
T_series <- vector(mode = "numeric", length = 0)
# Run Simulation
while(sim.time < num.steps){
n <- sum(N)
r <- sum(R)
im <- if (n < init) {((init + im.b) - n)} else {im.b};
em <- if (n < init) {floor(0.1 * n)} else {em.b};
# Timestep
interval <- rexp(1, rate = n*b - n*d + r*u + im + em + z)
ints <- c(ints, interval)
sim.time <- sim.time + interval
# Pick Event
event = sample(c('birth', 'death', 'decay',
'immigration', 'emigration', 'zombie'),
size = 1, prob = c(b*n, d*n, r*u, im, em, z))
switch(event,
birth = birth(N = N, b = b, otus = otus),
death = death(N = N, R = R, d = d, otus = otus),
decay = decay(R = R, u = u, otus = otus,
method = decay.m,
a.decay = a.decay, b.decay = b.decay),
immigration = immigration(N = N, G = G, im = im, otus = otus),
emigration = emigration(N = N, em = em, otus = otus),
zombie = zombie(R = R, G = G, z = z, otus = otus),
stop("event must be either \"birth\", \"death\", \"decay\",
\"immigration\", \"emigration\", or \"zombie\""))
# Store Event
event.list <- c(event.list, event)
N_series <- c(N_series, sum(N))
R_series <- c(R_series, sum(R))
T_series <- c(T_series, sim.time)
# Print Statement
print(paste("Time = ", round(sim.time, 3), ": ", event,
"; N = ", sum(N), "; R = ", sum(R), sep = ""))
=======
jelly.jar <- as.integer(jelly.jar)
require (vegan)
RACresults <- rad.lognormal(jelly.jar)
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25)
sample.community <- function (x,n){
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
# for reproducible results we will set the seed
set.seed(3)
# sample using our fuction
sample.jelly <- sample.community(x=jelly.jar,n=100)
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample")
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
sample.community <- function (x,n){
# sample size cannot exceed community size
if (n > sum(x)) stop ("Sample size cannot exceed total size of community")
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
par(mfrow=c(1,1))
par(mfrow=c(1,1))
plot.new()
par(mfrow=c(1,1))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
#par(mfrow=c(1,1))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample")
# Number of individuales per sample
n <- 100
# Number of repeated samples
N <- 1000
# initialize matrix to store results
repeated.S <- matrix(NA, nrow = N, ncol = length(S))
colnames(repeated.S) <- names(S)
# resample and store results
for (i in seq(N)){
sample.jelly <- sample.community(x=jelly.jar,n=n)
repeated.S[i,] <- as.vector(estimateR(sample.jelly))
}
#plot distribution of results as histogram
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab=i, main = NULL, col="grey")
#add dashed line to mark true S
abline(v=length(jelly.jar), lty=2, lwd=3)
}
S <- estimateR(sample.jelly)
S
# Number of individuales per sample
n <- 100
# Number of repeated samples
N <- 1000
# initialize matrix to store results
repeated.S <- matrix(NA, nrow = N, ncol = length(S))
colnames(repeated.S) <- names(S)
# resample and store results
for (i in seq(N)){
sample.jelly <- sample.community(x=jelly.jar,n=n)
repeated.S[i,] <- as.vector(estimateR(sample.jelly))
}
#plot distribution of results as histogram
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab=i, main = NULL, col="grey")
#add dashed line to mark true S
abline(v=length(jelly.jar), lty=2, lwd=3)
}
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab = i,
main = NULL, col = "grey", las = 1)
#add dashed line to mark true S
abline(v = length(jelly.jar), lty = 2, lwd = 3)
}
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
sample.community <- function (x,n){
# sample size cannot exceed community size
if (n > sum(x)) stop ("Sample size cannot exceed total size of community")
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
S <- estimateR(sample.jelly)
S
x<-c(1,3,7,9,13)
x<-x*14
x<-c(1,3,7,9,13)
w<-x*14
(x+w)/15
x <- c(1, 2, 3, 4, 5)
w <- x * 14
x + w / 15
(x + w) / 15
v <- c(16.4, 16.0, 10.1, 16.8, 20.5, NA, 20.2, 13.1, 24.8, 20.2, 25.0, 20.5, 30.5, 31.4, 27.1)
max(v)
j <- c(rnorm(5, mean = 8, sd = 2))
z <- c(rnorm(5, mean = 25, sd = 10))
k <- cbind (j, z)
k
m <- as.matrix(read.table("data/matrix.txt", sep = "\t", header = FALSE))
n <- t(m)
nrow(n)
ncol(n)
require("vegan")
load(BCI)
BCI
data("BCI")
str(BCI)
require("vegan")
rm(list=ls())
require("vegan")
data("BCI")
head(BCI)
rm(list=ls())
require("vegan")
str(BCI)
data("BCI")
str(BCI)
packageVersion("vegan")
data("BCI")
BCI
library(ade4)
data(doubs)
str(doubs)
require(vegan)
sh GitMkdirQB.sh 2.Worksheets/11.PhyloTraits participant_repos.txt
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
```
# Load packages
```{r}
tidy.opts=list(width.cutoff=60)}
package.list <- c('ape', 'seqinr', 'muscle', 'phylolm', 'vegan', 'grid', 'png',
'phylobase', 'adephylo', 'geiger', 'picante', 'stats', 'RColorBrewer',
'caper', 'phylolm', 'pmc', 'ggplot2', 'tidyr', 'dplyr', 'phangorn', 'pander')
for (package in package.list) {
if (!require(package, character.only=TRUE, quietly=TRUE)) {
install.packages(package)
library(package, character.only=TRUE)
}
}
gr.data <- read.csv("data/grraw.csv", sep=",", header = TRUE, row.names = 1)
str(gr.data)
# Standadize Growth Rates Across Strains
gr.std <- gr.data / (apply(gr.data, 1, sum))
# Standadize Growth Rates Across Strains
p.growth.std <- gr.data / (apply(gr.data, 1, sum))
# Calculate Max Growth Rate
umax <- as.matrix((apply(gr.data, 1, max)))
round(apply(gr.std, 2, max), 4)
round(apply(gr.std, 2, min), 4)
```
# Calculate niche breadth (Levins 1968)
```{r}
levins <- function(p_xi = ""){
p = 0
for (i in p_xi){
p = p + i^2
}
nb = 1 / (length(p_xi) * p)
return(nb)
}
# Calculate niche breadth for Each Isolate
nb <- as.matrix(levins(gr.std))
# Add Row & Column Names to Niche Breadth Matrix
rownames(nb) <- rownames(gr.data)
colnames(nb) <- c("nb")
read.aln <- read.alignment(file = "./data/2019_ML_Tree/20190322_PhosTrait.fasta", format = "fasta")
# Convert Alignment File to DNAbin Object {ape}
p.DNAbin <- as.DNAbin(read.aln)
# Identify Base Pair Region of 16S rRNA Gene to Visuzlize
window <- p.DNAbin[,0:900]
# Command to Visusalize Sequence Alignment {ape}
image.DNAbin(window, cex.lab = 0.50)
# Optional Code Adds Grid to Help Visualize Rows of Sequences
grid(nrow(window), col = "lightgrey")
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bestTree.OutPhos")
ml.bootstrap <- drop.tip(ml.bootstrap.out, "Methanosarcina")
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
ml.bootstrap <- drop.tip(ml.bootstrap.out, "Methanosarcina")
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
mypalette <- colorRampPalette(brewer.pal(9, "YlOrRd"))
# Map Phosphorus Traits {adephylo}
par(mar=c(1,1,1,1) + 0.1)
x <- phylo4d(ml.bootstrap, p.growth.std)
table.phylo4d(x, treetype = "phylo", symbol = "colors", show.node = TRUE,
cex.label = 0.5, scale = FALSE, use.edge.length = FALSE,
edge.color = "black", edge.width = 2, box = FALSE,
col=mypalette(25), pch = 15, cex.symbol = 1.25,
ratio.tree = 0.5, cex.legend = 1.5, center = FALSE)
# Niche Breadth
par(mar=c(1,5,1,5) + 0.1)
x.nb <- phylo4d(ml.bootstrap, nb)
table.phylo4d(x.nb, treetype = "phylo", symbol = "colors", show.node = TRUE,
cex.label = 0.5, scale = FALSE, use.edge.length = FALSE,
edge.color = "black", edge.width = 2, box = FALSE,
col=mypalette(25), pch = 15, cex.symbol = 1.25,
var.label=("       NB"),
ratio.tree = 0.90, cex.legend = 1.5, center = FALSE)
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
```
# Load packages
```{r}
tidy.opts=list(width.cutoff=60)}
package.list <- c('ape', 'seqinr', 'muscle', 'phylolm', 'vegan', 'grid', 'png',
'phylobase', 'adephylo', 'geiger', 'picante', 'stats', 'RColorBrewer',
'caper', 'phylolm', 'pmc', 'ggplot2', 'tidyr', 'dplyr', 'phangorn', 'pander')
for (package in package.list) {
if (!require(package, character.only=TRUE, quietly=TRUE)) {
install.packages(package)
library(package, character.only=TRUE)
>>>>>>> upstream/master
}
# Summary and Print Statements
event_summary <-  table(Events = event.list)
time_series <- data.frame(Time = T_series, N = N_series, R = R_series)
print(event_summary)
print(data.frame(probs = cbind(birth = b*n, death = d*n, decay = r*u,
immigration = im, emigration = em, zombie = z)))
print(data.frame(perm = cbind(birth = b, death = d, decay = u,
immigrtion = im, emigration = em, zombie = z)))
return(list(N = N, R = R, intervals = ints,
events = event.list, time_series = time_series))
}
<<<<<<< HEAD
# Equal Birth and Death and Decay
model1 <- IR_model(steps = 20, b = 0.2, d = 0.2, u = 0.2, z = 10,
im.b = 50, em.b = 10, init = 500,
decay.m = "random")
# Rank Abundance Plot
K <- N + R
plot(rad(as.numeric(K) / sum(K)), type = "l", col = rgb(0,0,0,0.5), lwd = 5)
lines(rad(as.numeric(N) / sum(N)), col = rgb(0,0,1,0.5), lwd = 5)
lines(rad(as.numeric(R) / sum(R)), col = rgb(1,0,0,0.5), lwd = 5)
# Cumulative Abundance Distribution
nN <- seq(1, max(N), 1)
cN <- rep(NA, length(nN))
for(i in 1:length(cN)){
cN[i] <- sum(N[which(N >= i)])
}
cNrel <- cN / sum(N)
nR <- seq(1, max(R), 1)
cR <- rep(NA, length(nR))
for(i in 1:length(cR)){
cR[i] <- sum(R[which(R >= i)])
}
cRrel <- cR / sum(R)
plot(cNrel ~ log10(nN), col = "blue")
points(cRrel ~ log10(nR), col = "red")
max(R)
tR <- table(R)
plot(plot())
replicate(10, {
model1 <- IR_model(steps = 20, b = 0.2, d = 0.2, u = 0.2, z = 10,
im.b = 50, em.b = 10, init = 500,
uniform.decay = TRUE, den.depend = FALSE,
a.decay = 0.7, b.decay = 0.7)
# Rank Abundance Plot
K <- N + R
lines(rad(as.numeric(K) / sum(K)), col = rgb(0,0,0,0.5), lwd = 5)
lines(rad(as.numeric(N) / sum(N)), col = rgb(0,0,1,0.5), lwd = 5)
lines(rad(as.numeric(R) / sum(R)), col = rgb(1,0,0,0.5), lwd = 5)
})
replicate(10, {
model2 <- IR_model(steps = 50, b = 0.2, d = 0.2, u = 0.0002, z = 10,
im.b = 50, em.b = 10, init = 500,
decay.m = c("random", "sp.spec", "den.depend"),
a.decay = 0.7, b.decay = 0.7)
# Rank Abundance Plot
K <- N + R
lines(rad(as.numeric(K) / sum(K)), col = rgb(0,0,0,0.5), lwd = 5)
lines(rad(as.numeric(N) / sum(N)), col = rgb(0,0,1,0.5), lwd = 5)
lines(rad(as.numeric(R) / sum(R)), col = rgb(1,0,0,0.5), lwd = 5)
})
plot.new()
replicate(10, {
model2 <- IR_model(steps = 50, b = 0.2, d = 0.2, u = 0.0002, z = 10,
im.b = 50, em.b = 10, init = 500,
decay.m = c("random", "sp.spec", "den.depend"),
a.decay = 0.7, b.decay = 0.7)
# Rank Abundance Plot
K <- N + R
lines(rad(as.numeric(K) / sum(K)), col = rgb(0,0,0,0.5), lwd = 5)
lines(rad(as.numeric(N) / sum(N)), col = rgb(0,0,1,0.5), lwd = 5)
lines(rad(as.numeric(R) / sum(R)), col = rgb(1,0,0,0.5), lwd = 5)
})
warnings()
# Equal Birth and Death and Decay
model1 <- IR_model(steps = 20, b = 0.2, d = 0.2, u = 0.2, z = 10,
im.b = 50, em.b = 10, init = 500,
decay.m = "random")
# Rank Abundance Plot
K <- N + R
plot(rad(as.numeric(K) / sum(K)), type = "l", col = rgb(0,0,0,0.5), lwd = 5)
lines(rad(as.numeric(N) / sum(N)), col = rgb(0,0,1,0.5), lwd = 5)
lines(rad(as.numeric(R) / sum(R)), col = rgb(1,0,0,0.5), lwd = 5)
replicate(10, {
model1 <- IR_model(steps = 20, b = 0.2, d = 0.2, u = 0.2, z = 10,
im.b = 50, em.b = 10, init = 500,
uniform.decay = TRUE, den.depend = FALSE,
decay.m = "random")
# Rank Abundance Plot
K <- N + R
lines(rad(as.numeric(K) / sum(K)), col = rgb(0,0,0,0.5), lwd = 5)
lines(rad(as.numeric(N) / sum(N)), col = rgb(0,0,1,0.5), lwd = 5)
lines(rad(as.numeric(R) / sum(R)), col = rgb(1,0,0,0.5), lwd = 5)
})
model1 <- IR_model(steps = 20, b = 0.2, d = 0.2, u = 0.2, z = 10,
im.b = 50, em.b = 10, init = 500,
decay.m = "random")
replicate(10, {
model1 <- IR_model(steps = 20, b = 0.2, d = 0.2, u = 0.2, z = 10,
im.b = 50, em.b = 10, init = 500,
decay.m = "random")
# Rank Abundance Plot
K <- N + R
lines(rad(as.numeric(K) / sum(K)), col = rgb(0,0,0,0.5), lwd = 5)
lines(rad(as.numeric(N) / sum(N)), col = rgb(0,0,1,0.5), lwd = 5)
lines(rad(as.numeric(R) / sum(R)), col = rgb(1,0,0,0.5), lwd = 5)
})
# Slow Decay
rm(list = c("G", "N", "R"))
model2 <- IR_model(steps = 200, b = 0.2, d = 0.2, u = 0.02, z = 10,
im.b = 50, em.b = 10, init = 500,
decay.m = "random")
# Rank Abundance Plot
plot(rad(as.numeric(G)), type = "l")
K <- N + R
plot(rad(as.numeric(K) / sum(K)), type = "l")
lines(rad(as.numeric(N) / sum(N)), col = "blue")
lines(rad(as.numeric(R) / sum(R)), col = "red")
# Very Slow Decay
rm(list = c("G", "N", "R"))
model2 <- IR_model(steps = 500, b = 0.2, d = 0.2, u = 0.0002, z = 10,
im.b = 50, em.b = 10, init = 500,
decay.m = "random")
# Rank Abundance Plot
K <- N + R
plot(rad(as.numeric(K) / sum(K)), type = "l", col = rgb(0,0,0,0.5), lwd = 5)
lines(rad(as.numeric(N) / sum(N)), col = rgb(0,0,1,0.5), lwd = 5)
lines(rad(as.numeric(R) / sum(R)), col = rgb(1,0,0,0.5), lwd = 5)
replicate(10, {
model2 <- IR_model(steps = 500, b = 0.2, d = 0.2, u = 0.0002, z = 10,
im.b = 50, em.b = 10, init = 500,
decay.m = c("random", "sp.spec", "den.depend"),
a.decay = 0.7, b.decay = 0.7)
# Rank Abundance Plot
K <- N + R
lines(rad(as.numeric(K) / sum(K)), col = rgb(0,0,0,0.5), lwd = 5)
lines(rad(as.numeric(N) / sum(N)), col = rgb(0,0,1,0.5), lwd = 5)
lines(rad(as.numeric(R) / sum(R)), col = rgb(1,0,0,0.5), lwd = 5)
})
library("xcms")
# Chunk 1
rm(list=ls())
setwd("~/GitHub/PhosTrait")
# Chunk 2
=======
```
# Load growth rate data
```{r}
gr.data <- read.csv("data/grraw.csv", sep=",", header = TRUE, row.names = 1)
str(gr.data)
# Standadize Growth Rates Across Strains
gr.std <- gr.data / (apply(gr.data, 1, sum))
# Standadize Growth Rates Across Strains
p.growth.std <- gr.data / (apply(gr.data, 1, sum))
# Calculate Max Growth Rate
umax <- as.matrix((apply(gr.data, 1, max)))
round(apply(gr.std, 2, max), 4)
round(apply(gr.std, 2, min), 4)
```
# Calculate niche breadth (Levins 1968)
```{r}
levins <- function(p_xi = ""){
p = 0
for (i in p_xi){
p = p + i^2
}
nb = 1 / (length(p_xi) * p)
return(nb)
}
# Calculate niche breadth for Each Isolate
nb <- as.matrix(levins(gr.std))
# Add Row & Column Names to Niche Breadth Matrix
rownames(nb) <- rownames(gr.data)
colnames(nb) <- c("nb")
```
# Read in alignment and visualize
```{r}
# Read Alignment File {seqinr}
read.aln <- read.alignment(file = "./data/2019_ML_Tree/20190322_PhosTrait.fasta", format = "fasta")
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
ml.bootstrap <- drop.tip(ml.bootstrap.out, "Methanosarcina")
# Define Color Palette
mypalette <- colorRampPalette(brewer.pal(9, "YlOrRd"))
par(mar=c(1,1,1,1) + 0.1)
x <- phylo4d(ml.bootstrap, p.growth.std)
table.phylo4d(x, treetype = "phylo", symbol = "colors", show.node = TRUE,
cex.label = 0.5, scale = FALSE, use.edge.length = FALSE,
edge.color = "black", edge.width = 2, box = FALSE,
col=mypalette(25), pch = 15, cex.symbol = 1.25,
ratio.tree = 0.5, cex.legend = 1.5, center = FALSE)
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
```
# Load packages
```{r}
tidy.opts=list(width.cutoff=60)}
>>>>>>> upstream/master
package.list <- c('ape', 'seqinr', 'muscle', 'phylolm', 'vegan', 'grid', 'png',
'phylobase', 'adephylo', 'geiger', 'picante', 'stats', 'RColorBrewer',
'caper', 'phylolm', 'pmc', 'ggplot2', 'tidyr', 'dplyr', 'phangorn', 'pander')
for (package in package.list) {
if (!require(package, character.only=TRUE, quietly=TRUE)) {
install.packages(package)
library(package, character.only=TRUE)
}
}
<<<<<<< HEAD
# Chunk 3
=======
```
# Load growth rate data
```{r}
>>>>>>> upstream/master
gr.data <- read.csv("data/grraw.csv", sep=",", header = TRUE, row.names = 1)
str(gr.data)
# Standadize Growth Rates Across Strains
gr.std <- gr.data / (apply(gr.data, 1, sum))
# Standadize Growth Rates Across Strains
p.growth.std <- gr.data / (apply(gr.data, 1, sum))
# Calculate Max Growth Rate
umax <- as.matrix((apply(gr.data, 1, max)))
round(apply(gr.std, 2, max), 4)
round(apply(gr.std, 2, min), 4)
<<<<<<< HEAD
# Chunk 4
=======
>>>>>>> upstream/master
levins <- function(p_xi = ""){
p = 0
for (i in p_xi){
p = p + i^2
}
nb = 1 / (length(p_xi) * p)
return(nb)
}
# Calculate niche breadth for Each Isolate
nb <- as.matrix(levins(gr.std))
# Add Row & Column Names to Niche Breadth Matrix
rownames(nb) <- rownames(gr.data)
colnames(nb) <- c("nb")
<<<<<<< HEAD
# Chunk 5
# Read Alignment File {seqinr}
=======
>>>>>>> upstream/master
read.aln <- read.alignment(file = "./data/2019_ML_Tree/20190322_PhosTrait.fasta", format = "fasta")
# Convert Alignment File to DNAbin Object {ape}
p.DNAbin <- as.DNAbin(read.aln)
# Identify Base Pair Region of 16S rRNA Gene to Visuzlize
window <- p.DNAbin[,0:900]
# Command to Visusalize Sequence Alignment {ape}
image.DNAbin(window, cex.lab = 0.50)
# Optional Code Adds Grid to Help Visualize Rows of Sequences
grid(nrow(window), col = "lightgrey")
<<<<<<< HEAD
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
ml.full <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_Full")
ml.short <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_Short")
ml.full.root <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_FullRoot")
ml.short.root <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_ShortRoot")
# Remove Neighbors
ptrait.samps <- c(row.names(gr.data), "Methanosarcina")
ptrait.samps
neighbors <- setdiff(ml.bootstrap.out$tip.label, ptrait.samps)
ml.bootstrap.samps <- drop.tip(ml.bootstrap.out, neighbors)
ml.full.samps <- drop.tip(ml.full, setdiff(ml.full$tip.label, ptrait.samps))
ml.short.samps <- drop.tip(ml.short, setdiff(ml.short$tip.label, ptrait.samps))
setdiff(ml.short$tip.label, ptrait.samps)
ml.short.samps <- drop.tip(ml.short, setdiff(ml.short$tip.label, ptrait.samps))
ml.full.root.samps <- drop.tip(ml.full.root, setdiff(ml.full.root$tip.label, ptrait.samps))
ml.short.root.samps <- drop.tip(ml.short.root, setdiff(ml.short.root$tip.label, ptrait.samps))
s
# Root Using Outgroup
ml.bootstrap.rooted <- root(ml.bootstrap.samps, "Methanosarcina")
ml.full.samps.rooted <- root(ml.full.samps, "Methanosarcina")
ml.short.samps.rooted <- root(ml.short.samps, "Methanosarcina")
ml.full.root.samps.rooted <- root(ml.full.root.samps, "Methanosarcina")
ml.short.root.samps.rooted <- root(ml.short.root.samps, "Methanosarcina")
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.full.samps.rooted, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.full.samps.rooted, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.full.samps.rooted$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.short.samps.rooted, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.samps.rooted$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.full.root.samps.rooted, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.full.root.samps.rooted$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.short.root.samps.rooted, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.root.samps.rooted$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
# Root Using Outgroup
ml.bootstrap.rooted <- root(ml.bootstrap.samps, "Methanosarcina")
# Outgroup
ml.bootstrap <- drop.tip(ml.bootstrap.rooted, "Methanosarcina")
)
)
=======
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
ml.bootstrap <- drop.tip(ml.bootstrap.out, "Methanosarcina")
>>>>>>> upstream/master
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
<<<<<<< HEAD
# Outgroup
ml.bootstrap <- drop.tip(ml.bootstrap.rooted, "Methanosarcina")
ml.full.bootstrap <- drop.tip(ml.full.samps.rooted, "Methanosarcina")
ml.short.bootstrap <- drop.tip(ml.short.samps.rooted, "Methanosarcina")
ml.full.root.bootstrap <- drop.tip(ml.full.root.samps.rooted, "Methanosarcina")
ml.short.root.bootstrap <- drop.tip(ml.short.root.samps.rooted, "Methanosarcina")
help(drop.tip)
ml.full.samps <- ape::drop.tip(ml.full, setdiff(ml.full$tip.label, ptrait.samps))
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
ml.full <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_Full")
ml.short <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_Short")
ml.full.root <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_FullRoot")
ml.short.root <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_ShortRoot")
# Remove Neighbors
ptrait.samps <- c(row.names(gr.data), "Methanosarcina")
neighbors <- setdiff(ml.bootstrap.out$tip.label, ptrait.samps)
ml.bootstrap.samps <- ape::drop.tip(ml.bootstrap.out, neighbors)
ml.full.samps <- ape::drop.tip(ml.full, setdiff(ml.full$tip.label, ptrait.samps))
ml.short.samps <- ape::drop.tip(ml.short, setdiff(ml.short$tip.label, ptrait.samps))
ml.full.root.samps <- ape::drop.tip(ml.full.root, setdiff(ml.full.root$tip.label, ptrait.samps))
ml.short.root.samps <- ape::drop.tip(ml.short.root, setdiff(ml.short.root$tip.label, ptrait.samps))
# Root Using Outgroup
ml.bootstrap.rooted <- root(ml.bootstrap.samps, "Methanosarcina")
ml.full.samps.rooted <- root(ml.full.samps, "Methanosarcina")
ml.short.samps.rooted <- root(ml.short.samps, "Methanosarcina")
ml.full.root.samps.rooted <- root(ml.full.root.samps, "Methanosarcina")
ml.short.root.samps.rooted <- root(ml.short.root.samps, "Methanosarcina")
# Outgroup
ml.bootstrap <- drop.tip(ml.bootstrap.rooted, "Methanosarcina")
ml.full.bootstrap <- drop.tip(ml.full.samps.rooted, "Methanosarcina")
ml.short.bootstrap <- drop.tip(ml.short.samps.rooted, "Methanosarcina")
ml.full.root.bootstrap <- drop.tip(ml.full.root.samps.rooted, "Methanosarcina")
ml.short.root.bootstrap <- drop.tip(ml.short.root.samps.rooted, "Methanosarcina")
# Outgroup
ml.bootstrap <- ape::drop.tip(ml.bootstrap.rooted, "Methanosarcina")
ml.full.bootstrap <- ape::drop.tip(ml.full.samps.rooted, "Methanosarcina")
ml.short.bootstrap <- ape::drop.tip(ml.short.samps.rooted, "Methanosarcina")
ml.full.root.bootstrap <- ape::drop.tip(ml.full.root.samps.rooted, "Methanosarcina")
ml.short.root.bootstrap <- ape::drop.tip(ml.short.root.samps.rooted, "Methanosarcina")
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.full.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.full.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.full, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.full$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.short.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
ml.full <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_Full")
ml.short <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_Short")
ml.full.root <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_FullRoot")
ml.short.root <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_ShortRoot")
# Remove Neighbors
ptrait.samps <- c(row.names(gr.data), "Methanosarcina")
neighbors <- setdiff(ml.bootstrap.out$tip.label, ptrait.samps)
ml.bootstrap.samps <- ape::drop.tip(ml.bootstrap.out, neighbors)
ml.full.samps <- ape::drop.tip(ml.full, setdiff(ml.full$tip.label, ptrait.samps))
ml.short.samps <- ape::drop.tip(ml.short, setdiff(ml.short$tip.label, ptrait.samps))
ml.full.root.samps <- ape::drop.tip(ml.full.root, setdiff(ml.full.root$tip.label, ptrait.samps))
ml.short.root.samps <- ape::drop.tip(ml.short.root, setdiff(ml.short.root$tip.label, ptrait.samps))
# Root Using Outgroup
ml.bootstrap.rooted <- root(ml.bootstrap.samps, "Methanosarcina")
ml.full.samps.rooted <- root(ml.full.samps, "Methanosarcina")
ml.short.samps.rooted <- root(ml.short.samps, "Methanosarcina")
ml.full.root.samps.rooted <- root(ml.full.root.samps, "Methanosarcina")
ml.short.root.samps.rooted <- root(ml.short.root.samps, "Methanosarcina")
# Outgroup
ml.bootstrap <- ape::drop.tip(ml.bootstrap.rooted, "Methanosarcina")
ml.full.bootstrap <- ape::drop.tip(ml.full.samps.rooted, "Methanosarcina")
ml.short.bootstrap <- ape::drop.tip(ml.short.samps.rooted, "Methanosarcina")
ml.full.root.bootstrap <- ape::drop.tip(ml.full.root.samps.rooted, "Methanosarcina")
ml.short.root.bootstrap <- ape::drop.tip(ml.short.root.samps.rooted, "Methanosarcina")
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.full.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.full.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.short.root.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.root.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
plot.phylo(ml.short.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
plot.phylo(ml.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
ml.short.root <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.PhosRAxML_ShortRoot")
# Remove Neighbors
ptrait.samps <- c(row.names(gr.data), "Methanosarcina")
neighbors <- setdiff(ml.bootstrap.out$tip.label, ptrait.samps)
ml.bootstrap.samps <- ape::drop.tip(ml.bootstrap.out, neighbors)
ml.short.root.samps <- ape::drop.tip(ml.short.root, setdiff(ml.short.root$tip.label, ptrait.samps))
ml.short.root.samps.rooted <- root(ml.short.root.samps, "Methanosarcina")
ml.short.root.bootstrap <- ape::drop.tip(ml.short.root.samps.rooted, "Methanosarcina")
ml.short.root.bootstrap
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.short.root.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.root.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
help(drop.tip)
ml.short.root.samps.rooted <- ml.short.root.samps
# Outgroup
ml.bootstrap <- ape::drop.tip(ml.bootstrap.rooted, "Methanosarcina")
ml.full.bootstrap <- ape::drop.tip(ml.full.samps.rooted, "Methanosarcina")
ml.short.bootstrap <- ape::drop.tip(ml.short.samps.rooted, "Methanosarcina")
ml.full.root.bootstrap <- ape::drop.tip(ml.full.root.samps.rooted, "Methanosarcina")
ml.short.root.bootstrap <- ape::drop.tip(ml.short.root.samps.rooted, "Methanosarcina")
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.short.root.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.root.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
ml.short.root.bootstrap <- ape::drop.tip(ml.short.root.samps.rooted, "Methanosarcina", trim.internal = TRUE)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.short.root.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.root.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.short.root.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
par(mar = c(1,2,2,1) + 0.1)
plot.phylo(ml.short.root.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.root.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,2,2,1) + 0.1)
plot.phylo(ml.short.root.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
ml.short.root.bootstrap$node.label
ml.short.root.bootstrap
ml.short.root.bootstrap$node.label
ml.full$node.label
ml.short$node.label
ml.short.root <- read.tree("./data/2019_ML_Tree/RAxML_bipartitionsBranchLabels.PhosRAxML_Short")
ml.short.root.samps <- ape::drop.tip(ml.short.root, setdiff(ml.short.root$tip.label, ptrait.samps))
ml.short.root.samps.rooted <- ml.short.root.samps
ml.short.root.bootstrap <- ape::drop.tip(ml.short.root.samps.rooted, "Methanosarcina", trim.internal = TRUE)
par(mar = c(1,2,2,1) + 0.1)
par(mar = c(1,2,2,1) + 0.1)
plot.phylo(ml.short.root.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.root.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
par(mar = c(1,2,2,1) + 0.1)
plot.phylo(ml.short.root.samps.rooted, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.short.root.samps.rooted$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
ml.short <- read.tree("./data/2019_ML_Tree/RAxML_bipartitionsBranchLabels.PhosRAxML_Short ")
ml.short <- read.tree("./data/2019_ML_Tree/RAxML_bipartitionsBranchLabels.PhosRAxML_Short ")
ml.short <- read.tree("./data/2019_ML_Tree/RAxML_bipartitionsBranchLabels.PhosRAxML_Short")
ml.short$node.label
=======
mypalette <- colorRampPalette(brewer.pal(9, "YlOrRd"))
# Map Phosphorus Traits {adephylo}
par(mar=c(1,1,1,1) + 0.1)
x <- phylo4d(ml.bootstrap, p.growth.std)
ml.bootstrap
summary(ml.bootstrap)
read.aln
summary(read.aln)
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
summary(ml.bootstrap.out)
ml.bootstrap.out$tip.label
tip.lab <- ml.bootstrap[ which(ml.bootstrap$tip.label=='WG14', ]
tip.lab <- ml.bootstrap[ which(ml.bootstrap$tip.label=='WG14'), ]
mlbootstrap.reduced <- ml.bootstrap[ which(ml.bootstrap$tip.label=='WG14'), ]
ml.bootstrap$tip.label=='WG14'
mlbootstrap.reduced <- ml.bootstrap[which(ml.bootstrap$tip.label=='WG14'), ]
rm(list=ls())
library(tidyverse)
library(cowplot)
install.packages("tidyverse")
require("tidyverse")
install.packages("cowplot")
install.packages("cowplot")
mut.freq <- seq(0,1,0.01)
equal.fitness <- mut.freq
wt.favored <- mut.freq^2
mutant.favored <- (2*equal.fitness)-wt.favored
phage.modify <- (2*equal.fitness)-mut.freq^1.3
d <- data.frame(mut.freq,equal.fitness,mutant.favored,wt.favored,phage.modify)
dl <- gather(data = d,key = model, value = final.freq ,"equal.fitness","mutant.favored","wt.favored", "phage.modify")
ggplot(dl, aes(x=mut.freq, y=final.freq))+
geom_line(aes(linetype=model, color=model), size=1.5)+
theme(legend.position = "bottom")+
xlab("Mutant freq. at start")+
ylab("Mutant freq. at end")+
draw_line(x = c(0.45, 0.45),
y = c(mutant.favored[45],phage.modify[45]),
arrow = arrow(length = unit(0.3, "cm")), size = 1.5)+
draw_line(x = c(0.55, 0.55),
y = c(mutant.favored[55],wt.favored[55]),
arrow = arrow(length = unit(0.3, "cm")), size = 1.5, linetype=5)
>>>>>>> upstream/master
