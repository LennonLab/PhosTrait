# draw 20 random numbers from log-normal distribution with a mean of 5 (log scale)
jelly.jar <- rlnorm (n = 20, meanlog = 5 )
# draw 20 random numbers from log-normal distribution with a mean of 5 (log scale)
jelly.jar <- rlnorm(n = 20, meanlog = 5 )
# force numbers to integers
jelly.jar <- as.integer(jelly.jar)
require (vegan)
RACresults <- rad.lognormal(jelly.jar)
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25)
sample.community <- function (x,n){
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
# for reproducible results we will set the seed
set.seed(3)
# sample using our fuction
sample.jelly <- sample.community(x=jelly.jar,n=100)
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample")
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
sample.community <- function (x,n){
# sample size cannot exceed community size
if (n > sum(x)) stop ("Sample size cannot exceed total size of community")
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
par(mfrow=c(1,1))
par(mfrow=c(1,1))
plot.new()
par(mfrow=c(1,1))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
#par(mfrow=c(1,1))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample")
# Number of individuales per sample
n <- 100
# Number of repeated samples
N <- 1000
# initialize matrix to store results
repeated.S <- matrix(NA, nrow = N, ncol = length(S))
colnames(repeated.S) <- names(S)
# resample and store results
for (i in seq(N)){
sample.jelly <- sample.community(x=jelly.jar,n=n)
repeated.S[i,] <- as.vector(estimateR(sample.jelly))
}
#plot distribution of results as histogram
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab=i, main = NULL, col="grey")
#add dashed line to mark true S
abline(v=length(jelly.jar), lty=2, lwd=3)
}
S <- estimateR(sample.jelly)
S
# Number of individuales per sample
n <- 100
# Number of repeated samples
N <- 1000
# initialize matrix to store results
repeated.S <- matrix(NA, nrow = N, ncol = length(S))
colnames(repeated.S) <- names(S)
# resample and store results
for (i in seq(N)){
sample.jelly <- sample.community(x=jelly.jar,n=n)
repeated.S[i,] <- as.vector(estimateR(sample.jelly))
}
#plot distribution of results as histogram
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab=i, main = NULL, col="grey")
#add dashed line to mark true S
abline(v=length(jelly.jar), lty=2, lwd=3)
}
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab = i,
main = NULL, col = "grey", las = 1)
#add dashed line to mark true S
abline(v = length(jelly.jar), lty = 2, lwd = 3)
}
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
sample.community <- function (x,n){
# sample size cannot exceed community size
if (n > sum(x)) stop ("Sample size cannot exceed total size of community")
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
S <- estimateR(sample.jelly)
S
x<-c(1,3,7,9,13)
x<-x*14
x<-c(1,3,7,9,13)
w<-x*14
(x+w)/15
x <- c(1, 2, 3, 4, 5)
w <- x * 14
x + w / 15
(x + w) / 15
v <- c(16.4, 16.0, 10.1, 16.8, 20.5, NA, 20.2, 13.1, 24.8, 20.2, 25.0, 20.5, 30.5, 31.4, 27.1)
max(v)
j <- c(rnorm(5, mean = 8, sd = 2))
z <- c(rnorm(5, mean = 25, sd = 10))
k <- cbind (j, z)
k
m <- as.matrix(read.table("data/matrix.txt", sep = "\t", header = FALSE))
n <- t(m)
nrow(n)
ncol(n)
require("vegan")
load(BCI)
BCI
data("BCI")
str(BCI)
require("vegan")
rm(list=ls())
require("vegan")
data("BCI")
head(BCI)
rm(list=ls())
require("vegan")
str(BCI)
data("BCI")
str(BCI)
packageVersion("vegan")
data("BCI")
BCI
library(ade4)
data(doubs)
str(doubs)
require(vegan)
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
```
Load package for writing figures
```{r}
require("png")
require("vegan")
require("pvclust")
require("gplots")
require("gridGraphics")
require("grid")
require("gplots")
require("gridExtra")
```
Load data (note this is raw growth rates)
```{r}
# Raw growth rate data
gr.data <- read.csv("data/grraw.csv", sep=",", header=TRUE)
str(gr.data)
colnames(gr.data)[1]<-"isolate"
# Data standardizing - log10 tranformation
log.gr <- log10(gr.data[,2:19]+1)
# Data standardizing - divide by sum of species growth
gr.std <- gr.data[,2:19] / (apply(gr.data[,2:19], 1, sum))
# Names
resources <- colnames(gr.data[,2:19])
strains <- gr.data[,1]
yellow.red.colors <- colorRampPalette(c("yellow","orange", "red"))
distance <- "euclidean"
# manhattan, correlation, uncentered,
# abscor, euclidean, bray
# Identify agglomerative method
clust <- "average"
# complete = furthest neighbor; compact clusters, sensitive to outliers
# average = UPGMA; considered robust
# ward.D = popular, but makes clusters of equal size and sensitive to outliers
# ward.D2 = dissimilarities are squared before clustering
# mcquitty
# median = downweights outliers
# centroid = fairly robust
# single = nearest neighbor; chaining problem
log.gr.mat <- as.matrix(log.gr)
colnames(log.gr.mat) <- colnames(gr.data[,2:19])
rownames(log.gr.mat) <- gr.data[,1]
rand <- matrix(sample(log.gr.mat), nrow = nrow(log.gr))
rand.heat <- heatmap.2(as.matrix(rand), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
# Calculate column means
col.means <-colMeans(log.gr)
# Calculate standard deviation of columns
col.sd <- apply(log.gr, 2, sd)
# Create dataframe with mean column and sd
col.wise <- mapply(rnorm, nrow(log.gr), col.means, col.sd/30)
colnames(col.wise) <- resources
# Make heatmap
col.heat <- heatmap.2(as.matrix(col.wise), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
# Create dataframe with mean column and sd
col.wise <- mapply(rnorm, nrow(log.gr), col.means, col.sd/30)
colnames(col.wise) <- resources
# Calculate standard deviation of columns
col.sd <- apply(log.gr, 2, sd)
# Calculate column means
col.means <-colMeans(log.gr)
col.wise <- mapply(rnorm, nrow(log.gr), col.means, col.sd/30)
colnames(col.wise) <- resources
col.heat <- heatmap.2(as.matrix(col.wise), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
plot.new()
col.heat <- heatmap.2(as.matrix(col.wise), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
row.means <-rowMeans(log.gr)
# Calculate standard deviation of rows
row.sd <- apply(log.gr, 1, sd)
# Create dataframe with mean rows and sd
row.wise <- t(mapply(rnorm,ncol(log.gr), row.means, row.sd/30))
colnames(row.wise) <- colnames(log.gr)
row.heat <- heatmap.2(as.matrix(row.wise), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
plot.new()
row.heat <- heatmap.2(as.matrix(row.wise), distfun = function(x)
vegdist(x, method = distance),
hclustfun = function(x) hclust(x, method = clust),
col = yellow.red.colors, trace = "none", density.info = "none",
labRow = strains, labCol = resources)
actual.heat <- heatmap.2(as.matrix(log.gr), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = yellow.red.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources)
plot.new()
actual.heat <- heatmap.2(as.matrix(log.gr), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = yellow.red.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources)
heat.list <- list(rand, col.wise, row.wise, log.gr)
# Function for running through list
grab_grob <- function(){
grid.echo()
grid.grab()
}
gl <- lapply(1:4, function(i){
heatmap.2(as.matrix(heat.list[[i]]), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = gray.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources, key = FALSE, keysize = 1.0, symkey = FALSE,
scale = "none", cexRow = 0.75, cexCol = 0.75,
lmat = rbind( c(0, 3), c(2,1), c(0,4) ), lhei = c(0.25, 4, 0.25 ),
)
grab_grob()
})
png(filename="~/GitHub/PhosTrait/figures/HeatMap.png", width = 2400,
height = 2400, res = 96*2)
grid.newpage()
grid.arrange(grobs = gl, ncol = 2, clip = TRUE)
dev.off()
graphics.off()
plot.new()
grab_grob <- function(){
grid.echo()
grid.grab()
}
gl <- lapply(1:4, function(i){
heatmap.2(as.matrix(heat.list[[i]]), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = gray.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources, key = FALSE, keysize = 1.0, symkey = FALSE,
scale = "none", cexRow = 0.75, cexCol = 0.75,
lmat = rbind( c(0, 3), c(2,1), c(0,4) ), lhei = c(0.25, 4, 0.25 ),
)
grab_grob()
})
png(filename="~/GitHub/PhosTrait/figures/HeatMap.png", width = 2400,
height = 2400, res = 96*2)
grid.newpage()
grid.arrange(grobs = gl, ncol = 2, clip = TRUE)
dev.off()
graphics.off()
heat.list <- list(rand, col.wise, row.wise, log.gr)
# Function for running through list
grab_grob <- function(){
grid.echo()
grid.grab()
}
gl <- lapply(1:4, function(i){
heatmap.2(as.matrix(heat.list[[i]]), distfun = function(x)
vegdist(x, method = distance), hclustfun = function(x)
hclust(x, method = clust), col = gray.colors, trace = "none",
density.info = "none", labRow = strains,
labCol = resources, key = FALSE, keysize = 1.0, symkey = FALSE,
scale = "none", cexRow = 0.75, cexCol = 0.75,
lmat = rbind( c(0, 3), c(2,1), c(0,4) ), lhei = c(0.25, 4, 0.25 ),
)
grab_grob()
})
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
require("png")
require("vegan")
require("phylolm")
require("seqinr")
require("ape")
require("phytools")
# Read Alignment File {seqinr}
read.aln <- read.alignment(file = "./data/p.isolates.afa", format = "fasta")
# Convert Alignment File to DNAbin Object {ape}
p.DNAbin <- as.DNAbin(read.aln)
# Identify Base Pair Region of 16S rRNA Gene to Visuzlize
window <- p.DNAbin[, 100:500]
# Command to Visusalize Sequence Alignment {ape}
image.DNAbin(window, cex.lab = 0.50)
# Create Distance Matrix with "F84" Model {ape}
seq.dist.84 <- dist.dna(p.DNAbin, model = "F84", pairwise.deletion = FALSE)
# Neighbor Joining Algorithm to Construct Tree, a 'phylo' Object {ape}
nj.tree <- bionj(seq.dist.84)
# Identify Outgroup Sequence
outgroup <- match("Methanosarcina", nj.tree$tip.label)
# Root the Tree {ape}
nj.rooted <- root(nj.tree, outgroup, resolve.root = TRUE)
# Plot the Rooted Tree{ape}
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(nj.rooted, main = "Neigbor Joining Tree", "phylogram",
use.edge.length = FALSE, direction = "right", cex = 0.6,
label.offset = 1)
add.scale.bar(cex = 0.7)
# Keep Rooted but Drop Outgroup Branch
p.tree <- drop.tip(nj.rooted, "Methanosarcina")
gr.data <- read.csv("data/grraw.csv", sep=",", header=TRUE) # column = resources
colnames(gr.data)[1]<-"isolate"
# Data standardizing: 0 - 1
norm.g <- function(x) (x-min(x))/(max(x)-min(x))
norm.g.data <- apply(gr.data[,2:19], 1, norm.g)
colnames(norm.g.data)<-gr.data[,1]
# Ordering
#row.names(norm.g.data) <- c()
norm.sort <- apply(norm.g.data, 2, sort, decreasing=T)
# Ranks
ranks <- as.vector(seq(1, dim(norm.sort)[1]))
# Little Long and Wintergreen data
LL <- norm.sort[,1:18]
WG <- norm.sort[,19:39]
plot.new()
matplot(ranks,LL, type = "l", lty = 2, lwd = 2, col = "blue", xlab = "Rank phosphorus preference",
ylab = "Scaled growth rate", xlim = c(0,20), ylim = c(0, 1), las = 1)
matlines(ranks,WG, type = "l", lty = 3, lwd = 1.5, col = "red")
# Quantify evenness
evar <- function(x){
x <- as.vector(x[x > 0])
1 - (2/pi)*atan(var(log(x)))
}
evar.LL <- apply(LL,2,evar)
evar.WG <- apply(WG,2,evar)
t.test(evar.LL, evar.WG)
wilcox.test(evar.LL,evar.WG)
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
SimpE <- function(x = ""){
S <- S.obs(x)
x = as.data.frame(x)
D <- diversity(x, "inv")
E <- (D)/S
return(E)
}
simpe.LL <- SimpE(LL)
simpe.LL <- simpe.LL[is.finite(simpe.LL)]
simpe.WG <- SimpE(WG)
simpe.WG <- simpe.WG[is.finite(simpe.WG)]
t.test(simpe.LL, simpe.WG)
wilcox.test(simpe.LL,simpe.WG)
