jelly.jar <- as.integer(jelly.jar)
require (vegan)
RACresults <- rad.lognormal(jelly.jar)
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25)
sample.community <- function (x,n){
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
# for reproducible results we will set the seed
set.seed(3)
# sample using our fuction
sample.jelly <- sample.community(x=jelly.jar,n=100)
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample")
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
sample.community <- function (x,n){
# sample size cannot exceed community size
if (n > sum(x)) stop ("Sample size cannot exceed total size of community")
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
par(mfrow=c(1,1))
par(mfrow=c(1,1))
plot.new()
par(mfrow=c(1,1))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
#par(mfrow=c(1,1))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample")
# Number of individuales per sample
n <- 100
# Number of repeated samples
N <- 1000
# initialize matrix to store results
repeated.S <- matrix(NA, nrow = N, ncol = length(S))
colnames(repeated.S) <- names(S)
# resample and store results
for (i in seq(N)){
sample.jelly <- sample.community(x=jelly.jar,n=n)
repeated.S[i,] <- as.vector(estimateR(sample.jelly))
}
#plot distribution of results as histogram
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab=i, main = NULL, col="grey")
#add dashed line to mark true S
abline(v=length(jelly.jar), lty=2, lwd=3)
}
S <- estimateR(sample.jelly)
S
# Number of individuales per sample
n <- 100
# Number of repeated samples
N <- 1000
# initialize matrix to store results
repeated.S <- matrix(NA, nrow = N, ncol = length(S))
colnames(repeated.S) <- names(S)
# resample and store results
for (i in seq(N)){
sample.jelly <- sample.community(x=jelly.jar,n=n)
repeated.S[i,] <- as.vector(estimateR(sample.jelly))
}
#plot distribution of results as histogram
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab=i, main = NULL, col="grey")
#add dashed line to mark true S
abline(v=length(jelly.jar), lty=2, lwd=3)
}
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab = i,
main = NULL, col = "grey", las = 1)
#add dashed line to mark true S
abline(v = length(jelly.jar), lty = 2, lwd = 3)
}
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
sample.community <- function (x,n){
# sample size cannot exceed community size
if (n > sum(x)) stop ("Sample size cannot exceed total size of community")
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
S <- estimateR(sample.jelly)
S
x<-c(1,3,7,9,13)
x<-x*14
x<-c(1,3,7,9,13)
w<-x*14
(x+w)/15
x <- c(1, 2, 3, 4, 5)
w <- x * 14
x + w / 15
(x + w) / 15
v <- c(16.4, 16.0, 10.1, 16.8, 20.5, NA, 20.2, 13.1, 24.8, 20.2, 25.0, 20.5, 30.5, 31.4, 27.1)
max(v)
j <- c(rnorm(5, mean = 8, sd = 2))
z <- c(rnorm(5, mean = 25, sd = 10))
k <- cbind (j, z)
k
m <- as.matrix(read.table("data/matrix.txt", sep = "\t", header = FALSE))
n <- t(m)
nrow(n)
ncol(n)
require("vegan")
load(BCI)
BCI
data("BCI")
str(BCI)
require("vegan")
rm(list=ls())
require("vegan")
data("BCI")
head(BCI)
rm(list=ls())
require("vegan")
str(BCI)
data("BCI")
str(BCI)
packageVersion("vegan")
data("BCI")
BCI
library(ade4)
data(doubs)
str(doubs)
require(vegan)
sh GitMkdirQB.sh 2.Worksheets/11.PhyloTraits participant_repos.txt
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
```
# Load packages
```{r}
tidy.opts=list(width.cutoff=60)}
package.list <- c('ape', 'seqinr', 'muscle', 'phylolm', 'vegan', 'grid', 'png',
'phylobase', 'adephylo', 'geiger', 'picante', 'stats', 'RColorBrewer',
'caper', 'phylolm', 'pmc', 'ggplot2', 'tidyr', 'dplyr', 'phangorn', 'pander')
for (package in package.list) {
if (!require(package, character.only=TRUE, quietly=TRUE)) {
install.packages(package)
library(package, character.only=TRUE)
}
}
gr.data <- read.csv("data/grraw.csv", sep=",", header = TRUE, row.names = 1)
str(gr.data)
# Standadize Growth Rates Across Strains
gr.std <- gr.data / (apply(gr.data, 1, sum))
# Standadize Growth Rates Across Strains
p.growth.std <- gr.data / (apply(gr.data, 1, sum))
# Calculate Max Growth Rate
umax <- as.matrix((apply(gr.data, 1, max)))
round(apply(gr.std, 2, max), 4)
round(apply(gr.std, 2, min), 4)
```
# Calculate niche breadth (Levins 1968)
```{r}
levins <- function(p_xi = ""){
p = 0
for (i in p_xi){
p = p + i^2
}
nb = 1 / (length(p_xi) * p)
return(nb)
}
# Calculate niche breadth for Each Isolate
nb <- as.matrix(levins(gr.std))
# Add Row & Column Names to Niche Breadth Matrix
rownames(nb) <- rownames(gr.data)
colnames(nb) <- c("nb")
read.aln <- read.alignment(file = "./data/2019_ML_Tree/20190322_PhosTrait.fasta", format = "fasta")
# Convert Alignment File to DNAbin Object {ape}
p.DNAbin <- as.DNAbin(read.aln)
# Identify Base Pair Region of 16S rRNA Gene to Visuzlize
window <- p.DNAbin[,0:900]
# Command to Visusalize Sequence Alignment {ape}
image.DNAbin(window, cex.lab = 0.50)
# Optional Code Adds Grid to Help Visualize Rows of Sequences
grid(nrow(window), col = "lightgrey")
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bestTree.OutPhos")
ml.bootstrap <- drop.tip(ml.bootstrap.out, "Methanosarcina")
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
ml.bootstrap <- drop.tip(ml.bootstrap.out, "Methanosarcina")
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
mypalette <- colorRampPalette(brewer.pal(9, "YlOrRd"))
# Map Phosphorus Traits {adephylo}
par(mar=c(1,1,1,1) + 0.1)
x <- phylo4d(ml.bootstrap, p.growth.std)
table.phylo4d(x, treetype = "phylo", symbol = "colors", show.node = TRUE,
cex.label = 0.5, scale = FALSE, use.edge.length = FALSE,
edge.color = "black", edge.width = 2, box = FALSE,
col=mypalette(25), pch = 15, cex.symbol = 1.25,
ratio.tree = 0.5, cex.legend = 1.5, center = FALSE)
# Niche Breadth
par(mar=c(1,5,1,5) + 0.1)
x.nb <- phylo4d(ml.bootstrap, nb)
table.phylo4d(x.nb, treetype = "phylo", symbol = "colors", show.node = TRUE,
cex.label = 0.5, scale = FALSE, use.edge.length = FALSE,
edge.color = "black", edge.width = 2, box = FALSE,
col=mypalette(25), pch = 15, cex.symbol = 1.25,
var.label=("       NB"),
ratio.tree = 0.90, cex.legend = 1.5, center = FALSE)
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
```
# Load packages
```{r}
tidy.opts=list(width.cutoff=60)}
package.list <- c('ape', 'seqinr', 'muscle', 'phylolm', 'vegan', 'grid', 'png',
'phylobase', 'adephylo', 'geiger', 'picante', 'stats', 'RColorBrewer',
'caper', 'phylolm', 'pmc', 'ggplot2', 'tidyr', 'dplyr', 'phangorn', 'pander')
for (package in package.list) {
if (!require(package, character.only=TRUE, quietly=TRUE)) {
install.packages(package)
library(package, character.only=TRUE)
}
}
```
# Load growth rate data
```{r}
gr.data <- read.csv("data/grraw.csv", sep=",", header = TRUE, row.names = 1)
str(gr.data)
# Standadize Growth Rates Across Strains
gr.std <- gr.data / (apply(gr.data, 1, sum))
# Standadize Growth Rates Across Strains
p.growth.std <- gr.data / (apply(gr.data, 1, sum))
# Calculate Max Growth Rate
umax <- as.matrix((apply(gr.data, 1, max)))
round(apply(gr.std, 2, max), 4)
round(apply(gr.std, 2, min), 4)
```
# Calculate niche breadth (Levins 1968)
```{r}
levins <- function(p_xi = ""){
p = 0
for (i in p_xi){
p = p + i^2
}
nb = 1 / (length(p_xi) * p)
return(nb)
}
# Calculate niche breadth for Each Isolate
nb <- as.matrix(levins(gr.std))
# Add Row & Column Names to Niche Breadth Matrix
rownames(nb) <- rownames(gr.data)
colnames(nb) <- c("nb")
```
# Read in alignment and visualize
```{r}
# Read Alignment File {seqinr}
read.aln <- read.alignment(file = "./data/2019_ML_Tree/20190322_PhosTrait.fasta", format = "fasta")
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
ml.bootstrap <- drop.tip(ml.bootstrap.out, "Methanosarcina")
# Define Color Palette
mypalette <- colorRampPalette(brewer.pal(9, "YlOrRd"))
par(mar=c(1,1,1,1) + 0.1)
x <- phylo4d(ml.bootstrap, p.growth.std)
table.phylo4d(x, treetype = "phylo", symbol = "colors", show.node = TRUE,
cex.label = 0.5, scale = FALSE, use.edge.length = FALSE,
edge.color = "black", edge.width = 2, box = FALSE,
col=mypalette(25), pch = 15, cex.symbol = 1.25,
ratio.tree = 0.5, cex.legend = 1.5, center = FALSE)
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
```
# Load packages
```{r}
tidy.opts=list(width.cutoff=60)}
package.list <- c('ape', 'seqinr', 'muscle', 'phylolm', 'vegan', 'grid', 'png',
'phylobase', 'adephylo', 'geiger', 'picante', 'stats', 'RColorBrewer',
'caper', 'phylolm', 'pmc', 'ggplot2', 'tidyr', 'dplyr', 'phangorn', 'pander')
for (package in package.list) {
if (!require(package, character.only=TRUE, quietly=TRUE)) {
install.packages(package)
library(package, character.only=TRUE)
}
}
```
# Load growth rate data
```{r}
gr.data <- read.csv("data/grraw.csv", sep=",", header = TRUE, row.names = 1)
str(gr.data)
# Standadize Growth Rates Across Strains
gr.std <- gr.data / (apply(gr.data, 1, sum))
# Standadize Growth Rates Across Strains
p.growth.std <- gr.data / (apply(gr.data, 1, sum))
# Calculate Max Growth Rate
umax <- as.matrix((apply(gr.data, 1, max)))
round(apply(gr.std, 2, max), 4)
round(apply(gr.std, 2, min), 4)
levins <- function(p_xi = ""){
p = 0
for (i in p_xi){
p = p + i^2
}
nb = 1 / (length(p_xi) * p)
return(nb)
}
# Calculate niche breadth for Each Isolate
nb <- as.matrix(levins(gr.std))
# Add Row & Column Names to Niche Breadth Matrix
rownames(nb) <- rownames(gr.data)
colnames(nb) <- c("nb")
read.aln <- read.alignment(file = "./data/2019_ML_Tree/20190322_PhosTrait.fasta", format = "fasta")
# Convert Alignment File to DNAbin Object {ape}
p.DNAbin <- as.DNAbin(read.aln)
# Identify Base Pair Region of 16S rRNA Gene to Visuzlize
window <- p.DNAbin[,0:900]
# Command to Visusalize Sequence Alignment {ape}
image.DNAbin(window, cex.lab = 0.50)
# Optional Code Adds Grid to Help Visualize Rows of Sequences
grid(nrow(window), col = "lightgrey")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
ml.bootstrap <- drop.tip(ml.bootstrap.out, "Methanosarcina")
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(ml.bootstrap, type = "phylogram", direction = "right", show.tip.label=TRUE,
use.edge.length = FALSE, cex = 0.6, label.offset = 1,
main = "Maximum Likelihood with Support Values")
add.scale.bar(cex = 0.7)
nodelabels(ml.bootstrap$node.label, font = 2, bg = "white", frame = "r", cex = 0.5)
mypalette <- colorRampPalette(brewer.pal(9, "YlOrRd"))
# Map Phosphorus Traits {adephylo}
par(mar=c(1,1,1,1) + 0.1)
x <- phylo4d(ml.bootstrap, p.growth.std)
ml.bootstrap
summary(ml.bootstrap)
read.aln
summary(read.aln)
# Keep Rooted but Drop Outgroup Branch
#ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap.out <- read.tree("./data/2019_ML_Tree/RAxML_bipartitions.OutPhos")
summary(ml.bootstrap.out)
ml.bootstrap.out$tip.label
tip.lab <- ml.bootstrap[ which(ml.bootstrap$tip.label=='WG14', ]
tip.lab <- ml.bootstrap[ which(ml.bootstrap$tip.label=='WG14'), ]
mlbootstrap.reduced <- ml.bootstrap[ which(ml.bootstrap$tip.label=='WG14'), ]
ml.bootstrap$tip.label=='WG14'
mlbootstrap.reduced <- ml.bootstrap[which(ml.bootstrap$tip.label=='WG14'), ]
rm(list=ls())
library(tidyverse)
library(cowplot)
install.packages("tidyverse")
require("tidyverse")
install.packages("cowplot")
install.packages("cowplot")
mut.freq <- seq(0,1,0.01)
equal.fitness <- mut.freq
wt.favored <- mut.freq^2
mutant.favored <- (2*equal.fitness)-wt.favored
phage.modify <- (2*equal.fitness)-mut.freq^1.3
d <- data.frame(mut.freq,equal.fitness,mutant.favored,wt.favored,phage.modify)
dl <- gather(data = d,key = model, value = final.freq ,"equal.fitness","mutant.favored","wt.favored", "phage.modify")
ggplot(dl, aes(x=mut.freq, y=final.freq))+
geom_line(aes(linetype=model, color=model), size=1.5)+
theme(legend.position = "bottom")+
xlab("Mutant freq. at start")+
ylab("Mutant freq. at end")+
draw_line(x = c(0.45, 0.45),
y = c(mutant.favored[45],phage.modify[45]),
arrow = arrow(length = unit(0.3, "cm")), size = 1.5)+
draw_line(x = c(0.55, 0.55),
y = c(mutant.favored[55],wt.favored[55]),
arrow = arrow(length = unit(0.3, "cm")), size = 1.5, linetype=5)
