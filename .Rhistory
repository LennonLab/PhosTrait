plot(fish.pcoa$points[ ,1], fish.pcoa$points[ ,2], ylim = c(-0.2, 0.7),
xlab = paste("PCoA 1 (", explainvar1, "%)", sep = ""),
ylab = paste("PCoA 2 (", explainvar2, "%)", sep = ""),
pch = 16, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = FALSE)
# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
# Add Points & Labels
points(fish.pcoa$points[ ,1], fish.pcoa$points[ ,2],
pch = 19, cex = 3, bg = "gray", col = "gray")
text(fish.pcoa$points[ ,1], fish.pcoa$points[ ,2],
labels = row.names(fish.pcoa$points))
# This first line <<pcoalayer1>> is calling the plot from the previous R chunk
# First we calculate the relative abundances of each species at each site
fishREL <- fish
for(i in 1:nrow(fish)){
fishREL[i, ] = fish[i, ] / sum(fish[i, ])
}
# Now, we use this information to calculate and add species scores
fish.pcoa <- add.spec.scores(fish.pcoa,fishREL,method = "pcoa.scores")
require("BiodiversityR")
install.packages("Rcmdr")
require("BiodiversityR")
# Now, we use this information to calculate and add species scores
fish.pcoa <- add.spec.scores(fish.pcoa,fishREL,method = "pcoa.scores")
?Control`
?Control
x <- 1:15
if (sample(x, 1) <= 10) {
print(paste("x is",x ,"and is less than 10"))
} else {
print(paste("x is",x,"and is greater than 10"))
}
for(i in 1:10){
print(i)
}
x <- c("apples", "oranges", "bananas", "strawberries")
for (i in seq(x)) {
print(x[i])
}
x <- c(apples, oranges, bananas, strawberries)
for (i in seq(x)) {
print(x[i])
}
for (i in (x)) {
print(x[i])
}
for (i in x) {
print(x[i])
}
?seq()
seq(x)
seq(x)
x <- c("apples", "oranges", "bananas", "strawberries") # x is a vector of fruit names
x
seq(x)
for (i in x) {
print(i)
}
for (i in seq(x)) {
len <- nchar(x[i])
print(len)
}
len <- ""
for (i in seq(x)) {
len[i] <- nchar(x[i])
}
print(len)
?tapply
len <- sapply(x, nchar)
len <- apply(x, nchar)
len <- tapply(x, nchar)
?sapply
i <- 1
while (i < 10) {
print(i)
i <- i + 1
}
i <- 1
while (i < 10) {
print(i)
i <- i - 1
}
dunif(x, min = 0, max = 1, log = FALSE)
dunif(x, min = 0, max = 1, log = FALSE)                       # Density
punif(q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)  # Probaility
qunif(p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)  # Qunatile
runif(n, min = 0, max = 1)                                    # Random Sample
# for reproducible results we will set the seed
set.seed(6)
# draw 20 random numbers from log-normal distribution with a mean of 5 (log scale)
jelly.jar <- rlnorm (n = 20, meanlog = 5 )
# draw 20 random numbers from log-normal distribution with a mean of 5 (log scale)
jelly.jar <- rlnorm(n = 20, meanlog = 5 )
# force numbers to integers
jelly.jar <- as.integer(jelly.jar)
require (vegan)
RACresults <- rad.lognormal(jelly.jar)
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25)
sample.community <- function (x,n){
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
# for reproducible results we will set the seed
set.seed(3)
# sample using our fuction
sample.jelly <- sample.community(x=jelly.jar,n=100)
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample")
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
sample.community <- function (x,n){
# sample size cannot exceed community size
if (n > sum(x)) stop ("Sample size cannot exceed total size of community")
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
par(mfrow=c(1,1))
par(mfrow=c(1,1))
plot.new()
par(mfrow=c(1,1))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
# generate RAC using vegan
RACsample <- rad.lognormal(sample.jelly)
plot.new()
#par(mfrow=c(1,1))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
points(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample", col = "red")
RACsample <- rad.lognormal(sample.jelly)
plot.new()
par(mfrow=c(1,2))
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main="Source community")
plot(RACsample, las = 1, cex.lab = 1.4, cex.axis = 1.25, xlim=c(1,20), main = "Sample")
# Number of individuales per sample
n <- 100
# Number of repeated samples
N <- 1000
# initialize matrix to store results
repeated.S <- matrix(NA, nrow = N, ncol = length(S))
colnames(repeated.S) <- names(S)
# resample and store results
for (i in seq(N)){
sample.jelly <- sample.community(x=jelly.jar,n=n)
repeated.S[i,] <- as.vector(estimateR(sample.jelly))
}
#plot distribution of results as histogram
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab=i, main = NULL, col="grey")
#add dashed line to mark true S
abline(v=length(jelly.jar), lty=2, lwd=3)
}
S <- estimateR(sample.jelly)
S
# Number of individuales per sample
n <- 100
# Number of repeated samples
N <- 1000
# initialize matrix to store results
repeated.S <- matrix(NA, nrow = N, ncol = length(S))
colnames(repeated.S) <- names(S)
# resample and store results
for (i in seq(N)){
sample.jelly <- sample.community(x=jelly.jar,n=n)
repeated.S[i,] <- as.vector(estimateR(sample.jelly))
}
#plot distribution of results as histogram
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab=i, main = NULL, col="grey")
#add dashed line to mark true S
abline(v=length(jelly.jar), lty=2, lwd=3)
}
plot.new()
par(mfrow=c(1,3))
for (i in c("S.obs", "S.chao1", "S.ACE")){
hist(repeated.S[,i],prob=TRUE,  cex.lab = 1.4, cex.axis = 1.25, xlab = i,
main = NULL, col = "grey", las = 1)
#add dashed line to mark true S
abline(v = length(jelly.jar), lty = 2, lwd = 3)
}
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
#take a single sample of size N from the source community
N<-1000
sample.dj <- sample.community(jelly.jar,n = N)
#generate vector to store results
S.collectors <- rep(NA, N)
#observed richness
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
#loop through 1:N and check S.obs
for (i in 1:N){
current <-  sample.community(sample.dj,n = i)
S.collectors[i] <- S.obs(t(current))
}
plot(1:N, S.collectors, xlab = "Sample size",ylab = "S.obs")
sample.community <- function (x,n){
# sample size cannot exceed community size
if (n > sum(x)) stop ("Sample size cannot exceed total size of community")
# write out an explicit vector of the community
all.individuals <- rep(seq(x), x)
# take n samples from the community
survey <- sample(all.individuals,n)
# prepare vector of species with 0 in each bin
survey.sum <- rep(0, length(x))
# add 1 to species bin each time an individual of that species was sampled
for ( i in survey){
survey.sum[i] <- survey.sum[i] + 1
}
return(survey.sum)
}
sample.community(x=jelly.jar,n=(sum(jelly.jar)+1))
S <- estimateR(sample.jelly)
S
x<-c(1,3,7,9,13)
x<-x*14
x<-c(1,3,7,9,13)
w<-x*14
(x+w)/15
x <- c(1, 2, 3, 4, 5)
w <- x * 14
x + w / 15
(x + w) / 15
v <- c(16.4, 16.0, 10.1, 16.8, 20.5, NA, 20.2, 13.1, 24.8, 20.2, 25.0, 20.5, 30.5, 31.4, 27.1)
max(v)
j <- c(rnorm(5, mean = 8, sd = 2))
z <- c(rnorm(5, mean = 25, sd = 10))
k <- cbind (j, z)
k
m <- as.matrix(read.table("data/matrix.txt", sep = "\t", header = FALSE))
n <- t(m)
nrow(n)
ncol(n)
require("vegan")
load(BCI)
BCI
data("BCI")
str(BCI)
require("vegan")
rm(list=ls())
require("vegan")
data("BCI")
head(BCI)
rm(list=ls())
require("vegan")
str(BCI)
data("BCI")
str(BCI)
packageVersion("vegan")
data("BCI")
BCI
library(ade4)
data(doubs)
str(doubs)
require(vegan)
sh GitMkdirQB.sh 2.Worksheets/11.PhyloTraits participant_repos.txt
rm(list=ls())
getwd()
setwd("~/GitHub/PhosTrait")
tidy.opts=list(width.cutoff=60)}
package.list <- c('ape', 'seqinr', 'muscle', 'phylolm', 'vegan', 'grid', 'png',
'phylobase', 'adephylo', 'geiger', 'picante', 'stats', 'RColorBrewer',
'caper', 'phylolm', 'pmc', 'ggplot2', 'tidyr', 'dplyr', 'phangorn', 'pander')
for (package in package.list) {
if (!require(package, character.only=TRUE, quietly=TRUE)) {
install.packages(package)
library(package, character.only=TRUE)
}
}
gr.data <- read.csv("data/grraw.csv", sep=",", header = TRUE, row.names = 1)
str(gr.data)
# Standadize Growth Rates Across Strains
gr.std <- gr.data / (apply(gr.data, 1, sum))
# Standadize Growth Rates Across Strains
p.growth.std <- gr.data / (apply(gr.data, 1, sum))
# Calculate Max Growth Rate
umax <- as.matrix((apply(gr.data, 1, max)))
round(apply(gr.std, 2, max), 4)
round(apply(gr.std, 2, min), 4)
```
# Calculate niche breadth (Levins 1968)
```{r}
levins <- function(p_xi = ""){
p = 0
for (i in p_xi){
p = p + i^2
}
nb = 1 / (length(p_xi) * p)
return(nb)
}
# Calculate niche breadth for Each Isolate
nb <- as.matrix(levins(gr.std))
# Add Row & Column Names to Niche Breadth Matrix
rownames(nb) <- rownames(gr.data)
colnames(nb) <- c("nb")
# Keep Rooted but Drop Outgroup Branch
ml.bootstrap.out <- read.tree("./data/ml_tree/RAxML_bipartitions.T1")
ml.bootstrap <- drop.tip(ml.bootstrap.out, "Methanosarcina")
# Visualize Trees With Different Levels of  Phylogenetic Signal {geiger}
ml.5 <- rescale(ml.bootstrap, "lambda", 0.5)
ml.0 <- rescale(ml.bootstrap, "lambda", 0)
layout(matrix(c(1,2,3), 1, 3), width = c(1, 1, 1))
par(mar=c(1,0.5,2,0.5)+0.1)
plot(ml.rooted, main = "lambda = 1", cex = 0.7, adj = 0.5)
plot(ml.bootstrap, main = "lambda = 1", cex = 0.7, adj = 0.5)
plot(ml.5, main = "lamba = 0.5", cex = 0.7, adj = 0.5)
plot(ml.0, main = "lamba = 0",  cex = 0.7, adj = 0.5)
# Generate Test Statistics for Comparing Phylogenetic Signal {geiger}
fitContinuous(ml.bootstrap, nb, model = "lambda")
fitContinuous(ml.0, nb, model = "lambda")
# First, Correct for Zero Branch-Lengths on Our Tree
ml.bootstrap$edge.length <- ml.bootstrap$edge.length + 10^-7
# Calculate Phylogenetic Signal for Growth on All Phosphorus Resources
# First, Create a Blank Output Matrix
p.phylosignal <- matrix(NA, 6, 18)
colnames(p.phylosignal) <- colnames(p.growth.std)
rownames(p.phylosignal) <- c("K", "PIC.var.obs", "PIC.var.mean",
"PIC.var.P", "PIC.var.z", "PIC.P.BH")
for (i in 1:18){
x <- as.matrix(p.growth.std[ ,i, drop = FALSE])
out <- phylosignal(x, ml.bootstrap)
p.phylosignal[1:5, i] <- round(t(out), 3)
}
# Use the BH Correction on P-values:
p.phylosignal[6, ] <- round(p.adjust(p.phylosignal[4, ], method = "BH"), 3)
# Calcualate Phylogenetic Signal for Niche Breadth
signal.nb <- phylosignal(nb, ml.bootstrap)
signal.nb
ml_0.5 <- rescale(ml.bootstrap, "lambda", 0.5)
ml_0.0 <- rescale(ml.bootstrap, "lambda", 0)
ml_0.5 <- rescale(ml.bootstrap, "lambda", 0.5)
ml_0.0 <- rescale(ml.bootstrap, "lambda", 0)
layout(matrix(c(1,2,3), 1, 3), width = c(1, 1, 1))
par(mar=c(1,0.5,2,0.5)+0.1)
plot(ml.bootstrap, main = "lambda = 1", cex = 0.7, adj = 0.5) # lambda = 1
plot(ml_0.5, main = "lamba = 0.5", cex = 0.7, adj = 0.5)
plot(ml_0.0, main = "lamba = 0",  cex = 0.7, adj = 0.5)
ml_1.0 <- rescale(ml.bootstrap, "lambda", 1)
ml_0.0 <- rescale(ml.bootstrap, "lambda", 0)
layout(matrix(c(1,2,3), 1, 3), width = c(1, 1, 1))
par(mar=c(1,0.5,2,0.5)+0.1)
plot(ml.bootstrap, main = "observed", cex = 0.7, adj = 0.5)
plot(ml_0.5, main = "lamba = 1", cex = 0.7, adj = 0.5)
plot(ml_0.0, main = "lamba = 0",  cex = 0.7, adj = 0.5)
# Generate test statistics for comparing phylogenetic signal {geiger}
fitContinuous(ml.bootstrap, nb, model = "lambda")
ml_1.0 <- rescale(ml.bootstrap, "lambda", 1)
ml_0.0 <- rescale(ml.bootstrap, "lambda", 0)
layout(matrix(c(1,2,3), 1, 3), width = c(1, 1, 1))
par(mar=c(1,0.5,2,0.5)+0.1)
plot(ml.bootstrap, main = "observed", cex = 0.7, adj = 0.5)
plot(ml_1.0, main = "lamba = 1", cex = 0.7, adj = 0.5)
plot(ml_0.0, main = "lamba = 0",  cex = 0.7, adj = 0.5)
# Generate test statistics for comparing phylogenetic signal {geiger}
fitContinuous(ml.bootstrap, nb, model = "lambda") # observed
# AIC = -33.073199
fitContinuous(ml_1.0, nb, model = "lambda")
ml_1.0 <- rescale(ml.bootstrap, "lambda", 1)
ml_0.5 <- rescale(ml.bootstrap, "lambda", 0.5)
ml_0.0 <- rescale(ml.bootstrap, "lambda", 0)
par(mar=c(1,0.5,2,0.5)+0.1)
plot(ml_1.0, main = "lambda = 1", cex = 0.7, adj = 0.5)
plot(ml_0.5, main = "lambda = 0.5", cex = 0.7, adj = 0.5)
plot(ml_0.0, main = "lambda = 0",  cex = 0.7, adj = 0.5)
# Generate test statistics for comparing phylogenetic signal {geiger}
fitContinuous(ml_1.0, nb, model = "lambda")
# AIC = -33.073199
fitContinuous(ml_0.5, nb, model = "lambda")
# Generate test statistics for comparing phylogenetic signal {geiger}
fitContinuous(ml_1.0, nb, model = "lambda")
# AIC = -33.073199
fitContinuous(ml_0.5, nb, model = "lambda")
#AIC = -33.073199
fitContinuous(ml_0.0, nb, model = "lambda")
ml_1.0 <- rescale(ml.bootstrap, "lambda", 1)
ml_0.5 <- rescale(ml.bootstrap, "lambda", 0.5)
ml_0.0 <- rescale(ml.bootstrap, "lambda", 0)
par(mar=c(1,0.5,2,0.5)+0.1)
plot(ml_1.0, main = "lambda = 1", cex = 0.7, adj = 0.5)
plot(ml_0.5, main = "lambda = 0.5", cex = 0.7, adj = 0.5)
plot(ml_0.0, main = "lambda = 0",  cex = 0.7, adj = 0.5)
# Generate test statistics for comparing phylogenetic signal {geiger}
fitContinuous(ml_1.0, nb, model = "lambda")
fitContinuous(ml_0.0, nb, model = "lambda")
fitContinuous(ml_0.0, nb, model = "BM")
fitContinuous(ml.bootstrap, nb, model = "lambda") #
fitContinuous(ml.bootstrap, nb, model = "OU")
fitContinuous(ml.bootstrap, nb, model = "EB")
fitContinuous(ml.bootstrap, nb, model = "trend")
fitContinuous(ml.bootstrap, nb, model = "kappa")
fitContinuous(ml.bootstrap, nb, model = "drift")
fitContinuous(ml.bootstrap, nb, model = "white")
# First, correct for zero branch-lengths on tree
ml.bootstrap$edge.length <- ml.bootstrap$edge.length + 10^-7
# Calculate phylogenetic signal for growth on all P resources
# Create blank output matrix
p.phylosignal <- matrix(NA, 6, 18)
colnames(p.phylosignal) <- colnames(p.growth.std)
rownames(p.phylosignal) <- c("K", "PIC.var.obs", "PIC.var.mean",
"PIC.var.P", "PIC.var.z", "PIC.P.BH")
for (i in 1:18){
x <- as.matrix(p.growth.std[ ,i, drop = FALSE])
out <- phylosignal(x, ml.bootstrap)
p.phylosignal[1:5, i] <- round(t(out), 3)
}
# Use the BH correction on P-values:
p.phylosignal[6, ] <- round(p.adjust(p.phylosignal[4, ], method = "BH"), 3)
p.phylosignal
?phylosignal
signal.nb <- phylosignal(nb, ml.bootstrap)
signal.nb
p.phylosignal[6, ]
signal.nb
